<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Neon Rune Rush - Fixed Speed</title>
    <style>
        :root {
            --bg-color: #050505;
            --text-color: #ffffff;
            --neon-cyan: #06b6d4;
            --neon-purple: #8b5cf6;
            --neon-yellow: #facc15;
            --neon-red: #ef4444;
            --font-main: 'Arial', sans-serif;
        }

        body {
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0; padding: 0;
            overflow: hidden;
            touch-action: none;
            font-family: var(--font-main);
            user-select: none;
            -webkit-user-select: none;
            width: 100vw; height: 100vh;
        }

        #gameCanvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            display: block;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 16px;
            box-sizing: border-box;
        }

        .hud-row { display: flex; justify-content: space-between; width: 100%; }
        .hud-item { display: flex; flex-direction: column; }
        .hud-label { font-size: 12px; color: #888; text-transform: uppercase; letter-spacing: 1px; }
        .hud-value { font-size: 32px; font-weight: bold; text-shadow: 0 0 10px rgba(255, 255, 255, 0.3); }

        #score-display { color: var(--neon-cyan); }
        #combo-display { color: var(--neon-yellow); text-align: right; }

        #feedback-msg {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 48px; font-weight: 900; font-style: italic;
            color: white; opacity: 0;
            text-shadow: 0 0 20px var(--neon-purple);
            pointer-events: none;
        }

        .bottom-zone { width: 100%; display: flex; justify-content: center; padding-bottom: 20px; }

        #panic-btn {
            position: relative;
            width: 80px; height: 80px;
            border-radius: 50%;
            background: #1f2937;
            border: 4px solid #4b5563;
            color: white; font-weight: bold; font-size: 14px;
            display: flex; align-items: center; justify-content: center;
            overflow: hidden; pointer-events: auto; cursor: pointer;
            box-shadow: 0 0 15px rgba(0,0,0,0.5);
            transition: transform 0.1s;
        }
        #panic-btn:active { transform: scale(0.9); }
        #panic-btn:disabled { opacity: 0.5; cursor: not-allowed; }

        #panic-fill {
            position: absolute; bottom: 0; left: 0;
            width: 100%; height: 0%;
            background-color: var(--neon-red);
            transition: height 0.2s linear; z-index: 0;
        }
        .btn-text { position: relative; z-index: 1; pointer-events: none; }
        #panic-glow {
            position: absolute; top: -4px; left: -4px; right: -4px; bottom: -4px;
            border-radius: 50%; border: 4px solid var(--neon-red);
            opacity: 0; animation: ping 1.5s infinite;
        }
        @keyframes ping { 75%, 100% { transform: scale(1.4); opacity: 0; } }

        #start-screen {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            display: flex; flex-direction: column;
            align-items: center; justify-content: center;
            z-index: 50; pointer-events: auto; text-align: center;
        }

        h1 {
            font-size: 48px;
            background: linear-gradient(to right, var(--neon-cyan), var(--neon-purple));
            -webkit-background-clip: text; -webkit-text-fill-color: transparent;
            margin: 0 0 10px 0; text-transform: uppercase;
        }
        p { color: #ccc; margin-bottom: 30px; }

        .tutorial-grid {
            display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 40px;
        }
        .tut-item { display: flex; flex-direction: column; align-items: center; color: #888; font-size: 12px; }
        .tut-symbol { font-size: 24px; color: white; font-weight: bold; margin-bottom: 5px; }

        .start-btn {
            padding: 15px 40px; background-color: var(--neon-cyan);
            color: black; font-weight: bold; font-size: 18px;
            border: none; border-radius: 50px; cursor: pointer;
            box-shadow: 0 0 20px rgba(6,182,212,0.4);
            transition: transform 0.1s;
        }
        .start-btn:active { transform: scale(0.95); }
    </style>
</head>
<body>

    <canvas id="gameCanvas"></canvas>

    <div id="ui-layer">
        <div class="hud-row">
            <div class="hud-item"><span class="hud-label">Score</span><span id="score-display" class="hud-value">0</span></div>
            <div class="hud-item" style="align-items: flex-end;"><span class="hud-label">Combo</span><span id="combo-display" class="hud-value">x0</span></div>
        </div>
        <div id="feedback-msg">NICE!</div>
        <div class="bottom-zone">
            <button id="panic-btn" disabled>
                <div id="panic-fill"></div>
                <span class="btn-text">BLAST</span>
                <div id="panic-glow"></div>
            </button>
        </div>
    </div>

    <div id="start-screen">
        <h1>Neon Rune</h1>
        <p>Fixed Version: Enemies now move correctly!</p>
        <div class="tutorial-grid">
            <div class="tut-item"><span class="tut-symbol">â€•</span>Horizontal</div>
            <div class="tut-item"><span class="tut-symbol">|</span>Vertical</div>
            <div class="tut-item"><span class="tut-symbol">V</span>V-Shape</div>
            <div class="tut-item"><span class="tut-symbol">O</span>Circle</div>
        </div>
        <button id="start-btn" class="start-btn">TAP TO START</button>
    </div>

<script>
// --- Audio Engine ---
const AudioContext = window.AudioContext || window.webkitAudioContext;
let audioCtx;
function initAudio() { if (!audioCtx) audioCtx = new AudioContext(); if (audioCtx.state === 'suspended') audioCtx.resume(); }
function playSound(type, pitchMultiplier=1) {
    if (!audioCtx) return;
    const osc = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();
    osc.connect(gainNode);
    gainNode.connect(audioCtx.destination);
    const now = audioCtx.currentTime;

    if (type === 'hit') {
        osc.type = 'sine';
        const base = 400;
        osc.frequency.setValueAtTime(base * pitchMultiplier, now);
        osc.frequency.exponentialRampToValueAtTime(base * pitchMultiplier * 2, now + 0.1);
        gainNode.gain.setValueAtTime(0.3, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
        osc.start(now); osc.stop(now + 0.1);
    } else if (type === 'die') {
        osc.type = 'square';
        osc.frequency.setValueAtTime(100, now);
        osc.frequency.exponentialRampToValueAtTime(0.01, now + 0.2);
        gainNode.gain.setValueAtTime(0.2, now);
        gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.2);
        osc.start(now); osc.stop(now + 0.2);
    } else if (type === 'blast') {
        osc.type = 'sawtooth';
        osc.frequency.setValueAtTime(50, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.5);
        gainNode.gain.setValueAtTime(0.5, now);
        gainNode.gain.linearRampToValueAtTime(0.01, now + 1.0);
        osc.start(now); osc.stop(now + 1.0);
    } else if (type === 'draw') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(200, now);
        gainNode.gain.setValueAtTime(0.05, now);
        gainNode.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.start(now); osc.stop(now + 0.05);
    }
}

// --- Game Engine ---
const CANVAS = document.getElementById('gameCanvas');
const CTX = CANVAS.getContext('2d');
const UI_SCORE = document.getElementById('score-display');
const UI_COMBO = document.getElementById('combo-display');
const BTN_PANIC = document.getElementById('panic-btn');
const FILL_PANIC = document.getElementById('panic-fill');
const MSG_FEEDBACK = document.getElementById('feedback-msg');
const GLOW_PANIC = document.getElementById('panic-glow');

let width, height;
let lastTime = 0;
let gameState = 'start';
let score = 0;
let combo = 0;
let panicCharge = 0;
const MAX_PANIC = 100;
let screenShake = 0;
let hitStopTimer = 0;
let timeScale = 1;

let enemies = [];
let particles = [];
let strokes = [];
let shockwaves = [];

const COLORS = { 'horz': '#06b6d4', 'vert': '#8b5cf6', 'circle': '#facc15', 'v': '#ef4444' };
const SHAPES = Object.keys(COLORS);

function resize() {
    width = window.innerWidth;
    height = window.innerHeight;
    CANVAS.width = width;
    CANVAS.height = height;
}
window.addEventListener('resize', resize);
resize();

// Input
let isDrawing = false;
function getPoint(e) { if(e.touches) return {x:e.touches[0].clientX, y:e.touches[0].clientY}; return {x:e.clientX, y:e.clientY}; }
function startDraw(e) {
    if(gameState !== 'playing') return;
    if(e.target.closest('#panic-btn')) return;
    isDrawing = true;
    const p = getPoint(e);
    strokes = [{x:p.x, y:p.y}];
    playSound('draw');
}
function moveDraw(e) {
    if(!isDrawing) return;
    const p = getPoint(e);
    const last = strokes[strokes.length-1];
    if(Math.hypot(p.x-last.x, p.y-last.y) > 5) strokes.push({x:p.x, y:p.y});
}
function endDraw() {
    if(!isDrawing) return;
    isDrawing = false;
    recognizeShape();
    setTimeout(() => { strokes = []; }, 100);
}
CANVAS.addEventListener('mousedown', startDraw);
CANVAS.addEventListener('mousemove', moveDraw);
window.addEventListener('mouseup', endDraw);
CANVAS.addEventListener('touchstart', startDraw, {passive:false});
CANVAS.addEventListener('touchmove', (e)=>{e.preventDefault(); moveDraw(e);}, {passive:false});
window.addEventListener('touchend', endDraw);

function recognizeShape() {
    if(strokes.length < 5) return;
    let minX=width, maxX=0, minY=height, maxY=0;
    strokes.forEach(p => {
        if(p.x<minX) minX=p.x; if(p.x>maxX) maxX=p.x;
        if(p.y<minY) minY=p.y; if(p.y>maxY) maxY=p.y;
    });
    const w = maxX-minX; const h = maxY-minY;
    const start = strokes[0]; const end = strokes[strokes.length-1];
    const dist = Math.hypot(start.x-end.x, start.y-end.y);
    let detected = null;

    if(dist < (w+h)*0.25 && strokes.length > 20) detected = 'circle';
    else if(w > h*2.5) detected = 'horz';
    else if(h > w*2.5) detected = 'vert';
    else {
        let lowestY = -1, lowestIdx = -1;
        strokes.forEach((p,i)=>{if(p.y>lowestY){lowestY=p.y; lowestIdx=i;}});
        if(lowestIdx>strokes.length*0.2 && lowestIdx<strokes.length*0.8) detected='v';
    }
    if(detected) processAction(detected);
}

function processAction(shape) {
    let target = null, closest = Infinity;
    const cx = width/2, cy = height/2;
    enemies.forEach(e => {
        if(e.shape === shape) {
            const dist = Math.hypot(e.x-cx, e.y-cy);
            if(dist < closest) { closest=dist; target=e; }
        }
    });
    if(target) {
        killEnemy(target);
        const center = strokes[Math.floor(strokes.length/2)];
        createShockwave(center.x, center.y, COLORS[shape]);
    } else {
        combo = 0; updateUI();
    }
}

// Logic
function spawnEnemy() {
    const edge = Math.floor(Math.random() * 4);
    const shape = SHAPES[Math.floor(Math.random() * SHAPES.length)];
    const size = 30 + Math.random() * 10;
    let x, y;
    
    // Spawn margin increased to ensure they are offscreen initially
    if(edge===0){x=Math.random()*width; y=-60;}
    else if(edge===1){x=width+60; y=Math.random()*height;}
    else if(edge===2){x=Math.random()*width; y=height+60;}
    else{x=-60; y=Math.random()*height;}

    // SPEED FIX: Pixels per Second, not per frame!
    // Base speed 150 px/s, increasing with score
    const speed = 150 + (score / 10); 
    const angle = Math.atan2((height/2)-y, (width/2)-x);
    
    enemies.push({
        x, y,
        vx: Math.cos(angle) * speed,
        vy: Math.sin(angle) * speed,
        shape, size, color: COLORS[shape],
        maxHp: 1
    });
}

function killEnemy(enemy) {
    enemies = enemies.filter(e => e !== enemy);
    score += 10 + (combo*2);
    combo++;
    panicCharge = Math.min(MAX_PANIC, panicCharge+15);
    
    playSound('hit', 1+Math.min(combo*0.1, 1.0));
    playSound('die', 0.5);
    
    hitStopTimer = 0.05; timeScale = 0.1; screenShake = 15;
    
    for(let i=0; i<12; i++) {
        particles.push({
            x:enemy.x, y:enemy.y,
            vx:(Math.random()-0.5)*200, vy:(Math.random()-0.5)*200,
            life:1.0, color:enemy.color, size:Math.random()*5+2
        });
    }
    updateUI(); showFeedback();
}

function usePanic() {
    if(panicCharge<MAX_PANIC) return;
    playSound('blast');
    screenShake = 35;
    shockwaves.push({x:width/2, y:height/2, r:10, maxR:Math.max(width,height)*1.2, alpha:1, color:'#ef4444'});
    enemies.forEach(e=>{
        for(let i=0; i<5; i++) particles.push({x:e.x, y:e.y, vx:(Math.random()-0.5)*300, vy:(Math.random()-0.5)*300, life:1.0, color:e.color, size:3});
    });
    score += enemies.length * 15;
    enemies = [];
    panicCharge = 0;
    updateUI();
}

function createShockwave(x, y, color) {
    shockwaves.push({x, y, r:5, maxR:100, alpha:1, color:color||'white'});
}

function updateUI() {
    UI_SCORE.innerText = score;
    UI_COMBO.innerText = "x" + combo;
    UI_COMBO.style.transform = `scale(${1+Math.min(combo*0.1, 0.4)})`;
    UI_COMBO.style.color = combo>5 ? COLORS.circle : 'white';
    FILL_PANIC.style.height = `${(panicCharge/MAX_PANIC)*100}%`;
    BTN_PANIC.disabled = panicCharge < MAX_PANIC;
    GLOW_PANIC.style.opacity = panicCharge>=MAX_PANIC ? 1 : 0;
}

function showFeedback() {
    if(combo>1 && combo%5===0) {
        const words = ['SWEET', 'EPIC!', 'RADICAL', 'GODLIKE'];
        MSG_FEEDBACK.innerText = words[Math.min(Math.floor(combo/5)-1, words.length-1)];
        MSG_FEEDBACK.style.opacity = 1;
        MSG_FEEDBACK.style.transform = "translate(-50%, -50%) scale(1.4)";
        setTimeout(()=>{
            MSG_FEEDBACK.style.opacity = 0; MSG_FEEDBACK.style.transform = "translate(-50%, -50%) scale(1)";
        }, 600);
    }
}

// Loop
function gameLoop(timestamp) {
    if(!lastTime) lastTime = timestamp;
    let dt = (timestamp - lastTime) / 1000;
    lastTime = timestamp;

    if(hitStopTimer > 0) {
        hitStopTimer -= dt;
        if(hitStopTimer <= 0) timeScale = 1;
        else dt *= timeScale;
    }

    if(gameState === 'playing') {
        update(dt);
        draw();
        if(screenShake > 0) screenShake *= 0.9;
        if(screenShake < 0.5) screenShake = 0;
        requestAnimationFrame(gameLoop);
    }
}

let spawnTimer = 0;
function update(dt) {
    spawnTimer -= dt;
    if(spawnTimer <= 0) {
        spawnEnemy();
        spawnTimer = Math.max(0.5, 2.0 - (score/2000));
    }
    
    // Entity update
    enemies.forEach(e => {
        e.x += e.vx * dt;
        e.y += e.vy * dt;
        if(Math.hypot(e.x-width/2, e.y-height/2) < 30) gameOver();
    });

    particles.forEach(p => {
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.life -= dt * 2.5;
        p.vy += 100 * dt; // Gravity
    });
    particles = particles.filter(p => p.life > 0);

    shockwaves.forEach(s => {
        s.r += 600 * dt;
        s.alpha -= 2 * dt;
    });
    shockwaves = shockwaves.filter(s => s.alpha > 0);
}

function draw() {
    CTX.fillStyle = 'rgba(5, 5, 10, 0.4)';
    CTX.fillRect(0, 0, width, height);
    CTX.save();
    if(screenShake > 0) CTX.translate((Math.random()-0.5)*screenShake, (Math.random()-0.5)*screenShake);

    // Base
    CTX.beginPath(); CTX.arc(width/2, height/2, 25, 0, Math.PI*2);
    CTX.fillStyle = '#22d3ee'; CTX.fill();
    CTX.strokeStyle = 'white'; CTX.lineWidth = 3; CTX.stroke();

    // Trail
    if(strokes.length>1) {
        CTX.beginPath(); CTX.moveTo(strokes[0].x, strokes[0].y);
        for(let i=1; i<strokes.length; i++) CTX.lineTo(strokes[i].x, strokes[i].y);
        CTX.strokeStyle = 'white'; CTX.lineWidth = 5;
        CTX.lineCap = 'round'; CTX.lineJoin = 'round';
        CTX.shadowColor = '#e879f9'; CTX.shadowBlur = 15; CTX.stroke(); CTX.shadowBlur = 0;
    }

    // Enemies
    enemies.forEach(e => {
        // Draw Warning Arrow if near edge
        if(e.x < 0 || e.x > width || e.y < 0 || e.y > height) {
            drawWarning(e);
        }

        CTX.save();
        CTX.translate(e.x, e.y);
        const speed = Math.hypot(e.vx, e.vy);
        const stretch = 1 + (speed * 0.0005); // Reduced stretch factor for high speed
        const rot = Math.atan2(e.vy, e.vx);
        CTX.rotate(rot); CTX.scale(stretch, 1/stretch); CTX.rotate(-rot);

        CTX.beginPath(); CTX.arc(0, 0, e.size, 0, Math.PI*2);
        CTX.fillStyle = '#111827'; CTX.fill();
        CTX.strokeStyle = e.color; CTX.lineWidth = 3; CTX.stroke();

        CTX.strokeStyle = 'white'; CTX.lineWidth = 4; CTX.lineCap = 'round'; CTX.beginPath();
        if(e.shape === 'horz'){CTX.moveTo(-10,0); CTX.lineTo(10,0);}
        else if(e.shape === 'vert'){CTX.moveTo(0,-10); CTX.lineTo(0,10);}
        else if(e.shape === 'circle'){CTX.arc(0,0,8,0,Math.PI*2);}
        else if(e.shape === 'v'){CTX.moveTo(-8,-5); CTX.lineTo(0,5); CTX.lineTo(8,-5);}
        CTX.stroke(); CTX.restore();
    });

    particles.forEach(p => {
        CTX.globalAlpha = p.life; CTX.fillStyle = p.color;
        CTX.beginPath(); CTX.arc(p.x, p.y, p.size, 0, Math.PI*2); CTX.fill();
    });
    CTX.globalAlpha = 1;

    shockwaves.forEach(s => {
        CTX.beginPath(); CTX.arc(s.x, s.y, s.r, 0, Math.PI*2);
        CTX.strokeStyle = s.color; CTX.lineWidth = 3;
        CTX.globalAlpha = s.alpha; CTX.stroke();
    });
    CTX.globalAlpha = 1;
    CTX.restore();
}

function drawWarning(e) {
    // Calculate position on edge
    const cx = width/2; const cy = height/2;
    const angle = Math.atan2(e.y - cy, e.x - cx);
    const radius = Math.min(width, height)/2 - 40;
    
    const wx = cx + Math.cos(angle) * radius;
    const wy = cy + Math.sin(angle) * radius;

    CTX.save();
    CTX.translate(wx, wy);
    CTX.rotate(angle);
    CTX.beginPath();
    CTX.moveTo(-10, -10); CTX.lineTo(10, 0); CTX.lineTo(-10, 10);
    CTX.fillStyle = e.color;
    CTX.fill();
    CTX.restore();
}

function gameOver() {
    gameState = 'gameover';
    document.getElementById('start-screen').style.display = 'flex';
    document.querySelector('#start-screen h1').innerText = "GAME OVER";
    document.querySelector('#start-screen p').innerText = `Score: ${score}`;
    document.getElementById('start-btn').innerText = "RETRY";
}

function startGame() {
    initAudio();
    gameState = 'playing';
    score = 0; combo = 0; panicCharge = 50;
    enemies = []; particles = []; shockwaves = [];
    updateUI();
    document.getElementById('start-screen').style.display = 'none';
    lastTime = performance.now();
    requestAnimationFrame(gameLoop);
}

document.getElementById('start-btn').addEventListener('click', startGame);
BTN_PANIC.addEventListener('click', (e)=>{e.stopPropagation(); usePanic();});

</script>
</body>
</html>

